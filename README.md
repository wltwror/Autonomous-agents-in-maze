# Autonomous agents in a maze

## Description
This project implements a 2D maze environment and two simple types of utility based agents.
The idea is to have two teams of different agents that are trying to beat the other team.
The goal of the agents is to pick up items and bring them to their delivery point.

## Game rules
- Agents cannot see the whole maze, only 5x5 cells around them, but they have memory and can remember the maze.
- In order to incentivize the agents to explore the maze, walls in the maze do not block their view.
- The agents can move in 4 directions (up, down, left, right) and can pick up and deliver items.
Agent can hold only one item at a time.
- Agent collision is neglected, so agents can walk through each other.
- Teams take turns to move.
- The game ends when all items are delivered.

## Implementation

### Agents
As mentioned above, there are two types of agents, both are utility based but differ in terms of cooperativeness.
Further in the text I will refer to them as cooperative and self-interested agents. Cooperative agents share
memory with their team and avoid competing with their teammates by reserving items. 
Self-interested agents do not share memory and disregard their teammates 
(not completely, they still consider them in utility calculation).

**Utility function**
The utility function is quite similar for both types of agents, but there are some differences to 
help self-interested agents avoid competing with their teammates.

- Cooperative agents:
    - Invalid move = -5 ( returns immediately)
    - Exploring a new cell = 1 for each cell (up to 5)
    - Closing distance to item = 8
    - Picking up an item = 12
    - Bringing an item closer to the delivery point = 7
    - Delivering item = 10
    - Getting closer to a teammate = -1 (up to -3 for 3 teammates)

- Self-interested agents:
    - Invalid move = -5 ( returns immediately)
    - Exploring a new cell = 1 for each cell (up to 5)
    - Closing distance to item = 4
    - Picking up an item = 12
    - Bringing an item closer to the delivery point = 7
    - Delivering item = 10
    - Getting closer to a teammate = -1 (up to -3 for 3 teammates)

For distance approximation agents use BFS to find the shortest path to a cell. 
Based on maze density the agents can either pick guaranteed path or riskier path shorter path. 
If no move generates positive utility, agent will use BFS to move in direction of closest unexplored cell.
This approach can cause some issues - if more agents are in the similar area they are likely to pick the same
path. Alternative approach would be to consider other agents when picking the path - probably feature for the future.

### Maze

The maze is *"randomly"* generated by placing agents, items and delivery points in random cells.
To guarantee that the maze is solvable, following algorithm is used:
- Two objects are randomly selected and a path is generated between them using modified DFS.
Those two items are added to an array of connected objects.
- Until an object is not in the array of connected objects, the following steps are repeated:
    - Randomly select an object from the array of connected objects
    - Randomly select an object from the array of not connected objects
    - Generate a path between them using modified DFS
    - Add the new object to the array of connected objects and remove from the array of not connected objects
- Add walls to the maze. The walls are placed randomly but the above created paths are guaranteed to be free of walls.
Amount of walls is determined by density constant (from 1 to 2 where 1 is 0% and 2 is 100%) and remaining empty cells
(no object, no path).

The "modified DFS" is essentially a heuristic DFS that uses a weighted rullet wheel to select the next cell. 
Moves closer ( according to manhattan distance ) to the target get 15 times more weight than moves away from the target.
The idea behind this is to get a short path (to avoid blocking too many cells for possible walls) 
but also not necessarily the shortest path.

## Running the application
There are two possible ways to run the application:

`python3 main.py` - runs the application in pygame, controls are:
- `Space` - next turn
- `A` - toggle automatic turns (10 per second by default)
- `Arrow key left` - show current memory of cooperative team
- `Arrow key right` - show current (cumulative) memory of self-interested team
- `Esc` - hide the memory display

Example pygame version:

![example](https://github.com/user-attachments/assets/157ff17f-d706-4c80-91e0-beeab1de5d5a)


`python3 main.py --run n` (where `n` is an integer) runs the application n times
and prints statistics to the console. The statistics include:
- number of wins for each team (and draws if any)
- total number of turns
- total score of both teams

Cooperative team is marked as team1 and self-interested team is marked as team2.



## Statistics
Following statistics were generated by running the application more than 100 times 
(1000 times except for the largest table) for each case. 


Maze size - 35x23, density 1.5, 6 agents (3 per team)

|                                 | 6 items | 7 items | 12 items |
|---------------------------------|---------|---------|----------|
| Cooperative team winrate        | 47.5%   | 75%     | 62%      |
| Self-interested team winrate    | 13.9%   | 25%     | 12%      |
| Draw                            | 38.6%   | 0%      | 26%      |
| Avg. cooperative team score     | 3.5     | 4.1     | 6.9      |
| Avg. self-interested team score | 2.5     | 2.9     | 5.1      |
| Avg. turns per game             | 106     | 112     | 148      |

Maze size - 100x100, density 1.5, 6 agents (3 per team)

|                                 | 7 items |
|---------------------------------|---------|
| Cooperative team winrate        | 81%     |
| Self-interested team winrate    | 19%     |
| Draw                            | 0%      |
| Avg. cooperative team score     | 4.3     |
| Avg. self-interested team score | 2.7     |
| Avg. turns per game             | 902     |


## Settings
Following relevant constants are located in `util/consts.py` file:
- density - density of the maze (1 to 2)
- maze_size - size of the maze (width, height)
- number of items
- number of agents
- auto-move delay (for pygame mode)

In the future I might add sliders to pygame mode to change those values on the fly.

## Other
Pygame version uses robot image to represent agents, the image 
is from [this website](https://icon-icons.com/icon/technology-robot/113340), under CC BY 4.0 license, author is
[Rudez Studio](https://icon-icons.com/users/VQZEcRjhvoQrxKTiDRNDT/icon-sets/).
